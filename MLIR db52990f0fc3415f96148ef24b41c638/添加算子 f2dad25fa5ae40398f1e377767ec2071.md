# 添加算子

1. Parser 中添加 |  支持
2. ODS框架中添加 | 算子 def
3. MLIRGen中添加 `builder.create<OrOp>(location, lhs, rhs)`;
4. Dialect.cpp中添加OrOp方法 parse print build infershape
5. 添加shfershape支持
6. Lowering 到 llvm dialect

### Parser 中添加 |  支持

```cpp
case '|':
      return 10;
```

### ODS框架中添加 | 算子 def

```cpp
//===----------------------------------------------------------------------===//
// OrOp
//===----------------------------------------------------------------------===//

def OrOp : Toy_Op<"Or", [Pure, DeclareOpInterfaceMethods<ShapeInferenceOpInterface>]> {
  let summary = "element-wise logic Or operation";
  let description = [{
    The "or" operation performs element-wise logic or between two tensors.
    The shapes of the tensor operands are expected to match.
  }];

  let arguments = (ins F64Tensor:$lhs, F64Tensor:$rhs);
  let results = (outs F64Tensor);

  // Indicate that the operation has a custom parser and printer method.
  let hasCustomAssemblyFormat = 1;

  // Allow building an AddOp with from the two input operands.
  let builders = [
    OpBuilder<(ins "Value":$lhs, "Value":$rhs)>
  ];
}
```

### MLIRGen中添加 `builder.create<OrOp>(location, lhs, rhs)`;

```cpp
case '|':
      return builder.create<OrOp>(location, lhs, rhs);
```

### Dialect.cpp中添加OrOp方法 parse print build infershape

```cpp
//===----------------------------------------------------------------------===//
// OrOp
//===----------------------------------------------------------------------===//
void OrOp::build(mlir::OpBuilder &builder, mlir::OperationState &state,
                  mlir::Value lhs, mlir::Value rhs) {
  state.addTypes(UnrankedTensorType::get(builder.getF64Type()));
  state.addOperands({lhs, rhs});
}
mlir::ParseResult OrOp::parse(mlir::OpAsmParser &parser,
                               mlir::OperationState &result) {
  return parseBinaryOp(parser, result);
}
void OrOp::print(mlir::OpAsmPrinter &p) { printBinaryOp(p, *this); }
void OrOp::inferShapes() { getResult().setType(getLhs().getType()); }
//===----------------------------------------------------------------------===//
```

### 添加shfershape支持

### Lowering 到 llvm dialect

auto opname = op->getName(); 判断是否为or操作 ，Or仅支持整型操作，但是输入数据是浮点型F64。因此，OrOp需要做一个浮点转整型的操作

```cpp
// Patch to support "toy.Or" Op
        if(nestedBuilder.getI64Type() == valueToStore.getType()) {
          valueToStore = nestedBuilder.create<mlir::arith::UIToFPOp>(loc, nestedBuilder.getF64Type(), valueToStore);
        }

        nestedBuilder.create<AffineStoreOp>(loc, valueToStore, alloc, ivs);
      });
```

```cpp
matchAndRewrite(Operation *op, ArrayRef<Value> operands,
                  ConversionPatternRewriter &rewriter) const final {
    auto loc = op->getLoc();
    lowerOpToLoops(op, operands, rewriter,
                   [loc,op](OpBuilder &builder, ValueRange memRefOperands,
                         ValueRange loopIvs) {
                     // Generate an adaptor for the remapped operands of the
                     // BinaryOp. This allows for using the nice named accessors
                     // that are generated by the ODS.
                     typename BinaryOp::Adaptor binaryAdaptor(memRefOperands);

                     // Generate loads for the element of 'lhs' and 'rhs' at the
                     // inner loop.
                     auto loadedLhs = builder.create<AffineLoadOp>(
                         loc, binaryAdaptor.getLhs(), loopIvs);
                     auto loadedRhs = builder.create<AffineLoadOp>(
                         loc, binaryAdaptor.getRhs(), loopIvs);
                      // patch to support "toy.or" operation.
                     auto opname = op->getName();
                     if (opname.getStringRef().str() == "toy.Or") {
                      auto castLhs = builder.create<mlir::arith::FPToUIOp>(loc, builder.getI64Type(), loadedLhs);
                      auto castRhs = builder.create<mlir::arith::FPToUIOp>(loc, builder.getI64Type(), loadedRhs);
                      
                      return builder.create<LoweredBinaryOp>(loc, castLhs, castRhs);
                    }

                     // Create the binary operation performed on the loaded
                     // values.
                     return builder.create<LoweredBinaryOp>(loc, loadedLhs,
                                                            loadedRhs);
                   });
```